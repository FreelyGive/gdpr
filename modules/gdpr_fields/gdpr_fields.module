<?php

/**
 * @file
 * Module file for the GDPR Fields module.
 */

/**
 * Implements hook_ctools_plugin_type().
 */
function gdpr_fields_ctools_plugin_type() {
  $plugins['gdpr_data'] = array(
    'classes' => array('handler'),
    'child plugins' => TRUE,
    'use hooks' => TRUE,
  );

  return $plugins;
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function gdpr_fields_ctools_plugin_directory($owner, $plugin_type) {
  if ($owner == 'gdpr_fields') {
    return 'plugins/' . $plugin_type;
  }
  if ($owner == 'ctools' && $plugin_type == 'export_ui') {
    return 'plugins/' . $plugin_type;
  }
}

/**
 * Fetch metadata for all context plugins.
 *
 * @return array
 *   An array of arrays with information about all available panel contexts.
 */
function gdpr_fields_get_gdpr_data() {
  ctools_include('plugins');

  return ctools_get_plugins('gdpr_fields', 'gdpr_data');
}

/**
 * Implements hook_gdpr_fields_default_field_data().
 *
 * Default hook for building field data plugins.
 */
function gdpr_fields_gdpr_fields_default_field_data() {
  $export =  array();

  $plugins = gdpr_fields_get_gdpr_data();
  foreach ($plugins as $name => $plugin) {
    $export[$name] = GDPRFieldData::createFromPlugin($plugin);
  }

  // Scan fields directory for default files.
  $files = file_scan_directory(dirname(__FILE__) . '/default_fields', '/\.field.php/', array('key' => 'name'));
  foreach ($files as $file) {
    $field = new GDPRFieldData();
    if ((include $file->uri) == 1) {
      $name = $field->plugin_type . ':' . $field->name;
      $export[$name] = $field;
    }
  }

  return $export;
}


function gdpr_fields_exluded_entities($relationship) {
  list($field, $from, $to) = explode('-', $relationship['name']);

  $exluded_source = array(
    'gdpr_task',
  );
  $exluded_destination = array(
    'gdpr_task',
  );

  if (in_array($from, $exluded_source)) {
    return TRUE;
  }

  if (in_array($to, $exluded_destination)) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Collect entities that are connected to a GDPR task.
 *
 * @param array &$entity_list
 * @param string $entity_type
 * @param int|stdClass $entity
 */
function gdpr_fields_collect_gdpr_entities(&$entity_list, $entity_type, $entity) {
  // Get the wrapper and entity id.
  $wrapper = entity_metadata_wrapper($entity_type, $entity);
  $entity_id = $wrapper->getIdentifier();
  
  // Check for recursion.
  if (isset($entity_list[$entity_type][$entity_id])) {
    return;
  }

  // Set entity.
  $entity_list[$entity_type][$entity_id] = $entity;
  
  // Loop over all defined properties and collect information.
  // @todo: Add a way to exclude specific properties.
  // @todo: Exclude entity types.
  foreach ($wrapper->getPropertyInfo() as $property_name => $property_info) {
    // Work out whether the property is a list and what type it is.
    $is_list = FALSE;
    $property_type = $property_info['type'];
    if ($list_type = entity_property_list_extract_type($property_type)) {
      $is_list = TRUE;
      $property_type = $list_type;
    }
    
    // If it is an entity property recursively call this function.
    if ($property_type == 'entity' || entity_get_info($property_type)) {
      if ($is_list) {
        foreach ($wrapper->{$property_name} as $property_wrapper) {
          gdpr_fields_collect_gdpr_entities(
            $entity_list,
            $property_type->type(),
            $property_wrapper->value()
          );
        }
      }
      else {
        gdpr_fields_collect_gdpr_entities(
          $entity_list,
          $wrapper->{$property_name}->type(),
          $wrapper->{$property_name}->value()
        );
      }
    }
    else if (!empty($property_info['property info'])) {
      // Because this recurses at an entity level rather than a property level
      // we do some limited manual recursion into 'struct' and other complex
      // property types. This recursion only goes one level deep, but covers
      // the uncommon use case where an entity referencing property has its
      // entity as a sub property.
      // Sub-sub-property entity references are NOT supported here - but we are
      // unaware of any modules that implement sub-sub-property reference.
      if ($is_list) {
        foreach ($wrapper->{$property_name} as $property_wrapper) {
          foreach ($property_wrapper->getPropertyInfo() as $sub_property_name => $sub_property_info) {
            $is_sub_list = FALSE;
            $sub_property_type = $sub_property_info['type'];
            if ($sub_list_type = entity_property_list_extract_type($sub_property_type)) {
              $is_sub_list = TRUE;
              $sub_property_type = $sub_list_type;
            }
            
            if ($sub_property_type == 'entity' || entity_get_info($sub_property_type)) {
              if ($is_list) {
                foreach ($property_wrapper->{$sub_property_name} as $sub_property_wrapper) {
                  gdpr_fields_collect_gdpr_entities(
                    $entity_list,
                    $sub_property_wrapper->type(),
                    $sub_property_wrapper->value()
                  );
                }
              }
              else {
                gdpr_fields_collect_gdpr_entities(
                  $entity_list,
                  $property_wrapper->{$sub_property_name}->type(),
                  $property_wrapper->{$sub_property_name}->value()
                );
              }
            }
          }
        }
      }
    }
  }
  
  return $entity_list;
}

/**
 * Implements hook_permission().
 */
function gdpr_fields_permission() {
  $perms = array(
    'administer gdpr fields' => array(
      'title' => t('Administer GDPR field settings'),
      'restrict access' => TRUE,
    ),
  );

  return $perms;
}
